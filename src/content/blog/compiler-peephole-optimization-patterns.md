---
slug: compiler-peephole-optimization-patterns
title: "Compiler Peephole Optimization Patterns"
excerpt: "How compilers apply local rewrite rules to instruction sequences for smaller, faster machine code."
coverGradient: "linear-gradient(135deg, hsl(129, 60%, 18%) 0%, hsl(189, 48%, 24%) 100%)"
author: Frost
date: "2025-07-20"
tags: ["Compilers"]
published: true
---

Peephole optimization examines small windows (peepholes) of generated instructions and replaces patterns with more efficient equivalents. Unlike global optimizations that require whole-program analysis, peephole optimizations are local, fast, and surprisingly effective at cleaning up code generated by earlier compiler phases.

## Common Peephole Patterns

The simplest patterns are algebraic simplifications: multiplying by 1, adding 0, or negating a negation. At the machine level, these become identity operations that waste cycles. More interesting patterns involve instruction combination: a load followed by an immediate store to the same location is redundant. A compare-and-branch sequence can sometimes be replaced by a conditional move.

## Strength Reduction

Replacing expensive operations with cheaper equivalents is a classic peephole optimization. Multiplication by a power of 2 becomes a left shift. Division by a constant becomes a multiply-and-shift sequence (using the reciprocal). Modulo by a power of 2 becomes a bitwise AND. These replacements save significant cycles, especially on architectures where division is expensive.

## Target-Specific Patterns

Each instruction set has unique peephole opportunities. On x86, LEA can perform complex address arithmetic in a single instruction. On ARM, many instructions have a free barrel shifter operand. RISC-V's compressed instruction extension can encode common patterns in 16-bit instructions instead of 32-bit. The peephole optimizer's pattern database is architecture-specific, tuned to exploit each ISA's strengths.
